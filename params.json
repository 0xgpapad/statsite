{"name":"Statsite","tagline":"A C implementation of statsite","body":"Statsite [![Build Status](https://travis-ci.org/armon/statsite.png)](https://travis-ci.org/armon/statsite)\r\n========\r\n\r\nThis is a stats aggregation server. Statsite is based heavily\r\non Etsy's StatsD <https://github.com/etsy/statsd>. This is\r\na re-implementation of the Python version of statsite\r\n<https://github.com/kiip/statsite>.\r\n\r\nFeatures\r\n--------\r\n\r\n* Basic key/value metrics\r\n* Send timer data, statsite will calculate:\r\n  - Mean\r\n  - Min/Max\r\n  - Standard deviation\r\n  - Median, Percentile 95, Percentile 99\r\n* Send counters that statsite will aggregate\r\n* Binary protocol\r\n\r\n\r\nArchitecture\r\n-------------\r\n\r\nStatsite is designed to be both highly performant,\r\nand very flexible. To achieve this, it implements the stats\r\ncollection and aggregation in pure C, using libev to be\r\nextremely fast. This allows it to handle hundreds of connections,\r\nand millions of metrics. After each flush interval expires,\r\nstatsite performs a fork/exec to start a new stream handler\r\ninvoking a specified application. Statsite then streams the\r\naggregated metrics over stdin to the application, which is\r\nfree to handle the metrics as it sees fit.\r\n\r\nThis allows statsite to aggregate metrics and then ship metrics\r\nto any number of sinks (Graphite, SQL databases, etc). There\r\nis an included Python script that ships metrics to graphite.\r\n\r\nAdditionally, statsite tries to minimize memory usage by not\r\nstoring all the metrics that are received. Counter values are\r\naggregated as they are received, and timer values are stored\r\nand aggregated using the Cormode-Muthurkrishnan algorithm from\r\n\"Effective Computation of Biased Quantiles over Data Streams\".\r\nThis means that the percentile values are not perfectly accurate,\r\nand are subject to a specifiable error epsilon. This allows us to\r\nstore only a fraction of the samples.\r\n\r\nInstall\r\n-------\r\n\r\nDownload and build from source::\r\n\r\n    $ git clone https://github.com/armon/statsite.git\r\n    $ cd statsite\r\n    $ pip install SCons  # Uses the Scons build system, may not be necessary\r\n    $ scons\r\n    $ ./statsite\r\n\r\nBuilding the test code may generate errors if libcheck is not available.\r\nTo build the test code successfully, do the following::\r\n\r\n    $ cd deps/check-0.9.8/\r\n    $ ./configure\r\n    $ make\r\n    # make install\r\n    # ldconfig (necessary on some Linux distros)\r\n    $ cd ../../\r\n    $ scons test_runner\r\n\r\nAt this point, the test code should build successfully.\r\n\r\nUsage\r\n-----\r\n\r\nStatsite is configured using a simple INI file.\r\nHere is an example configuration file::\r\n\r\n    [statsite]\r\n    port = 8125\r\n    udp_port = 8125\r\n    log_level = INFO\r\n    flush_interval = 10\r\n    timer_eps = 0.01\r\n    stream_cmd = python sinks/graphite.py localhost 2003\r\n\r\nThen run statsite, pointing it to that file::\r\n\r\n    statsite -f /etc/statsite.conf\r\n\r\nProtocol\r\n--------\r\n\r\nBy default, Statsite will listen for TCP and UDP connections. A message\r\nlooks like the following (where the flag is optional)::\r\n\r\n    key:value|type[|@flag]\r\n\r\nMessages must be terminated by newlines (`\\n`).\r\n\r\nCurrently supported message types:\r\n\r\n* `kv` - Simple Key/Value.\r\n* `g`  - Same as `kv`, compatibility with statsd gauges\r\n* `ms` - Timer.\r\n* `c` - Counter.\r\n\r\nAfter the flush interval, the counters and timers of the same key are\r\naggregated and this is sent to the store.\r\n\r\nExamples:\r\n\r\nThe following is a simple key/value pair, in this case reporting how many\r\nqueries we've seen in the last second on MySQL::\r\n\r\n    mysql.queries:1381|kv\r\n\r\nThe following is a timer, timing the response speed of an API call::\r\n\r\n    api.session_created:114|ms\r\n\r\nThe next example is increments the \"rewards\" counter by 1::\r\n\r\n    rewards:1|c\r\n\r\nAnd this example decrements the \"inventory\" counter by 7::\r\n\r\n    inventory:-7|c\r\n\r\n\r\nWriting Statsite Sinks\r\n---------------------\r\n\r\nStatsite only ships with a graphite sink by default, but any executable\r\ncan be used as a sink. The sink should read its inputs from stdin, where\r\neach metric is in the form::\r\n\r\n    key|val|timestamp\r\n\r\nEach metric is separated by a newline. The process should terminate with\r\nan exit code of 0 to indicate success.\r\n\r\n\r\nBinary Protocol\r\n---------------\r\n\r\nIn addition to the statsd compatible ASCII protocol, statsite includes\r\na lightweight binary protocol. This can be used if you want to make use\r\nof special characters such as the colon, pipe character, or newlines. It\r\nis also marginally faster to process, and may provide 10-20% more throughput.\r\n\r\nEach command is sent to statsite over the same ports in the following manner:\r\n\r\n    <Magic Byte><Metric Type><Key Length><Value><Key>\r\n\r\nThe \"Magic Byte\" is the value 0xaa (170). This switches the internal\r\nprocessing from the ASCII mode to binary. The metric type is one of:\r\n\r\n* 0x1 : Key value / Gauge\r\n* 0x2 : Counter\r\n* 0x3 : Timer\r\n\r\nThe key length is a 2 byte unsigned integer with the length of the\r\nkey, INCLUDING a NULL terminator. The key must include a null terminator,\r\nand it's length must include this.\r\n\r\nThe value is a standard IEEE754 double value, which is 8 bytes in length.\r\n\r\nLastly, the key is provided as a byte stream which is `Key Length` long,\r\nterminated by a NULL (0) byte.\r\n\r\nAll of these values must be transmitted in Little Endian order.\r\n\r\nHere is an example of sending (\"Conns\", \"c\", 200) as hex:\r\n\r\n    0xaa 0x02 0x0600 0x0000000000006940 0x436f6e6e7300\r\n\r\n\r\n\r\nBinary Sink Protocol\r\n--------------------\r\n\r\nIt is also possible to have the data streamed to be represented\r\nin a binary format. Again, this is used if you want to use the reserved\r\ncharacters. It may also be faster.\r\n\r\nEach command is sent to the sink in the following manner:\r\n\r\n    <Timestamp><Metric Type><Value Type><Key Length><Value><Key>\r\n\r\nMost of these are the same as the binary protocol. There are a few.\r\nchanges however. The Timestamp is sent as an 8 byte unsigned integer,\r\nwhich is the current Unix timestamp. The Metric type is one of:\r\n\r\n* 0x1 : Key value / Gauge\r\n* 0x2 : Counter\r\n* 0x3 : Timer\r\n\r\nThe value type is one of:\r\n\r\n* 0x0 : No type (Key/Value)\r\n* 0x1 : Sum\r\n* 0x2 : Sum Squared\r\n* 0x3 : Mean\r\n* 0x4 : Count\r\n* 0x5 : Standard deviation\r\n* 0x6 : Minimum Value\r\n* 0x7 : Maximum Value\r\n* 0x80 OR `percentile` :  If the type OR's with 128 (0x80), then it is a\r\n    percentile amount. The amount is OR'd with 0x80 to provide the type. For\r\n    example (0x80 | 0x32) = 0xb2 is the 50% percentile or medium. The 95th\r\n    percentile is (0x80 | 0xdf) = 0xdf.\r\n\r\nThe key length is a 2 byte unsigned integer representing the key length\r\nterminated by a NULL character. The Value is an IEEE754 double. Lastly,\r\nthe key is a NULL-terminated character stream.\r\n\r\nTo enable the binary sink protocol, add a configuration variable `binary_stream`\r\nto the configuration file with the value `yes`. An example sink is provided in\r\n`sinks/binary_sink.py`.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}