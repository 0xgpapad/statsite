import os, shutil, sys, subprocess, datetime
Import('env_statsite_with_err')  # exported by parent SConstruct

env = env_statsite_with_err
# I wanted to base the debian version number partly on the
# revision checked out from our Git repository.
# Skip this if it's not relevant to you.
scm_version = subprocess.check_output(["git", "describe", "--always"])[:-1]

# Here's the core info for the package

DEBNAME = "statsite"
# DEBVERSION = "0.01"
DEBVERSION = datetime.datetime.strftime(datetime.datetime.now(),
                                        '%Y%m%d%H%M%S')
                                    
DEBMAINT = "John Keates [john@keates.nl]"
DEBARCH = "amd64"
DEBDEPENDS = ""
# DEBDEPENDS = "other-package1, other-package2"  # what are we dependent on?
DEBDESC = "A C implementation of statsd by Etsy"

DEBFILES = [

    # Now we specify the files to be included in the .deb
    # Where they should go, and where they should be copied from.
    # If you have a lot of files, you may wish to generate this
    # list in some other way.
    ("usr/bin/statsite",             "#statsite"),
    ("usr/libexec/statsite/sinks/__init__.py",  "#sinks/__init__.py"),
    ("usr/libexec/statsite/sinks/binary_sink.py",  "#sinks/binary_sink.py"),
    ("usr/libexec/statsite/sinks/librato.py",  "#sinks/librato.py"),

    ("usr/libexec/statsite/sinks/statsite_json_sink.rb",
        "#sinks/statsite_json_sink.rb"),

    ("usr/libexec/statsite/sinks/gmetric.py",  "#sinks/gmetric.py"),
    ("usr/libexec/statsite/sinks/influxdb.py",  "#sinks/influxdb.py"),
    ("usr/libexec/statsite/sinks/graphite.py",  "#sinks/graphite.py"),
    ("usr/libexec/statsite/sinks/cloudwatch.sh",  "#sinks/cloudwatch.sh"),
    ("usr/libexec/statsite/sinks/opentsdb.js",  "#sinks/opentsdb.js"),
    ("lib/systemd/system/statsite.service",  "#rpm/statsite.service"),
    ("etc/statsite/statsite.conf",  "#rpm/statsite.conf.example"),
    ("etc/tmpfiles.d/statsite.conf",  "#rpm/statsite.tmpfiles.conf"),
]

# This is the debian package we're going to create
debpkg = '#%s_%s-%s_%s.deb' % (DEBNAME, DEBVERSION, scm_version, DEBARCH)

# and we want it to be built when we build 'debian'
env.Alias("debian", debpkg)

DEBCONTROLFILE = os.path.join(DEBNAME, "DEBIAN/control")

# This copies the necessary files into place into place.
# Fortunately, SCons creates the necessary directories for us.
for f in DEBFILES:
    # We put things in a directory named after the package
    dest = os.path.join(DEBNAME, f[0])
    # The .deb package will depend on this file
    env.Depends(debpkg, dest)
    # Copy from the the source tree.
    env.Command(dest, f[1], Copy('$TARGET', '$SOURCE'))
    # The control file also depends on each source because we'd like
    # to know the total installed size of the package
    env.Depends(DEBCONTROLFILE, dest)

# Now to create the control file:

CONTROL_TEMPLATE = """
Package: %s
Priority: extra
Section: misc
Installed-Size: %s
Maintainer: %s
Architecture: %s
Version: %s-%s
Depends: %s
Description: %s

"""
env.Depends(debpkg, DEBCONTROLFILE)

# The control file should be updated when the Git version changes
env.Depends(DEBCONTROLFILE, env.Value(scm_version))

# This function creates the control file from the template and info
# specified above, and works out the final size of the package.


def make_control(target=None, source=None, env=None):
    installed_size = 0
    for i in DEBFILES:
        installed_size += os.stat(str(env.File(i[1])))[6]
    control_info = CONTROL_TEMPLATE % (
        DEBNAME, installed_size, DEBMAINT, DEBARCH, DEBVERSION,
        scm_version, DEBDEPENDS, DEBDESC)
    f = open(str(target[0]), 'w')
    f.write(control_info)
    f.close()

# We can generate the control file by calling make_control
env.Command(DEBCONTROLFILE, None, make_control)

# And we can generate the .deb file by calling dpkg-deb
env.Command(debpkg, DEBCONTROLFILE,
            "fakeroot dpkg-deb -b %s %s" % ("deb/%s" % DEBNAME, "$TARGET"))
